Opcodes are defined in include/isa.h, limbo/optab.c and libinterp/xec.c.

consc is documented but does not exist in the opcode definitions.

Function signatures will be output by the Limbo compiler if you pass it the
"-D S" debug option.

For example, the Sys->print function has this summary output for it:

    signed Sys->print type fn(s: string, *): int len 6 sig 0xac849033

The type "fn(s: string, *): int" is how the function is declared in the
module/sys.m file.

Function signatures are generated by the sign function in the limbo/types.c
file. We add the debug code after the md5 function call:

    md5(sig, sigend, md5sig, nil);
    if(debug['S']) {
        print("sign %D len %d\n", d, sigend);
        print("%s\n", (char*)sig);
    }

This results in the following additional two debug lines:

    sign Sys->print len 6
    f*(s)i

The "f*(s)i" string is the function signature that needs to be hashed using the
MD5 algorithm. Additionally, the following code is used to reduce the hash
value to four bytes:

    for(i = 0; i < MD5dlen; i += 4)
        t->sig ^= md5sig[i+0] | (md5sig[i+1]<<8) | (md5sig[i+2]<<16) | (md5sig[i+3]<<24);

We can reproduce this in Python using the md5 module, obtaining the hash value
then combining each eight digit segment of it using XOR, before reversing the
endianness of the resulting value:

    import md5
    h = md5.md5("f*(s)i").hexdigest()
    l = map(lambda x: int(h[x:x+2], 16), range(0, 32, 2))
    hd = sum(map(lambda x: reduce(lambda y, z: y ^ z, l[x::4]) << (x * 8), range(4)))

The rtsign and idsign functions in the limbo/types.c file are responsible for
creating a signature for a function. The sigkind array contains the characters
used for each type of object that will be serialised.
